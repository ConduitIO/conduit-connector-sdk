// Copyright © 2023 Meroxa, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package internal

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"reflect"
	"strconv"
	"text/template"

	sdk "github.com/conduitio/conduit-connector-sdk"
)

const (
	tmpl = `// Code generated by paramgen. DO NOT EDIT.
// Source: github.com/ConduitIO/conduit-connector-sdk/tree/main/cmd/paramgen

package {{ $.Package }}

import (
	{{- if $.HasRegex }}
	"regexp"
	{{ end }}
	sdk "github.com/conduitio/conduit-connector-sdk"
)

func ({{ $.Struct }}) Parameters() map[string]sdk.Parameter {
	return map[string]sdk.Parameter{
		{{- range $name, $parameter := .Parameters }}
		{{ $.Quote $name }}: {
			Default:     {{ $.Quote .Default }},
			Description: {{ $.Quote .Description }},
			Type:        sdk.{{ .GetTypeConstant }},
			Validations: []sdk.Validation{
			{{- range $index, $validation := .Validations }}
				{{ $parameter.GetValidation $index }},
			{{- end }}
			},
		},
		{{- end }}
	}
}
`
)

type templateData struct {
	Parameters map[string]parameter
	Package    string
	Struct     string
}

func (templateData) Quote(s string) string {
	return strconv.Quote(s)
}

var parameterTypeConstantMapping = map[sdk.ParameterType]string{
	sdk.ParameterTypeString:   "ParameterTypeString",
	sdk.ParameterTypeInt:      "ParameterTypeInt",
	sdk.ParameterTypeFloat:    "ParameterTypeFloat",
	sdk.ParameterTypeBool:     "ParameterTypeBool",
	sdk.ParameterTypeFile:     "ParameterTypeFile",
	sdk.ParameterTypeDuration: "ParameterTypeDuration",
}

type parameter sdk.Parameter

func (p parameter) GetTypeConstant() string {
	return parameterTypeConstantMapping[p.Type]
}
func (p parameter) GetValidation(index int) string {
	validation := p.Validations[index]

	regexValidation, ok := validation.(sdk.ValidationRegex)
	if !ok {
		// default behavior
		return fmt.Sprintf("%#v", p.Validations[index])
	}

	validationType := reflect.TypeOf(validation).String()
	validationParameters := fmt.Sprintf("Regex: regexp.MustCompile(%q)", regexValidation.Regex)
	return fmt.Sprintf("%s{%s}", validationType, validationParameters)
}

func (t templateData) HasRegex() bool {
	for _, p := range t.Parameters {
		for _, v := range p.Validations {
			if _, ok := v.(sdk.ValidationRegex); ok {
				return true
			}
		}
	}
	return false
}

func GenerateCode(parameters map[string]sdk.Parameter, packageName string, structName string) string {
	// create the go template
	t := template.Must(template.New("").Parse(tmpl))

	internalParams := make(map[string]parameter, len(parameters))
	for k, v := range parameters {
		internalParams[k] = parameter(v)
	}

	data := templateData{
		Package:    packageName,
		Struct:     structName,
		Parameters: internalParams,
	}
	var processed bytes.Buffer
	// execute the template
	err := t.Execute(&processed, data)
	if err != nil {
		log.Fatalf("error: failed to execute template: %v", err)
	}

	// format the output as Go code in the “gofmt” style
	formatted, err := format.Source(processed.Bytes())
	if err != nil {
		log.Fatalf("error: could not format processed template: %v", err)
	}

	return string(formatted)
}
